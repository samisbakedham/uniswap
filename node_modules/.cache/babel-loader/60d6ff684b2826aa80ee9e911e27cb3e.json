{"ast":null,"code":"import _slicedToArray from\"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _defineProperty from\"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import{Trans}from\"@lingui/react\";import{CurrencyAmount,Price,Rounding}from'@uniswap/sdk-core';import{encodeSqrtRatioX96,nearestUsableTick,Pool,Position,priceToClosestTick,TICK_SPACINGS,TickMath,tickToPrice}from'@uniswap/v3-sdk';import{usePool}from'hooks/usePools';import JSBI from'jsbi';import{useCallback,useMemo}from'react';import{useAppDispatch,useAppSelector}from'state/hooks';import{getTickToPrice}from'utils/getTickToPrice';import{BIG_INT_ZERO}from'../../../constants/misc';import{PoolState}from'../../../hooks/usePools';import{useActiveWeb3React}from'../../../hooks/web3';import{tryParseAmount}from'../../swap/hooks';import{useCurrencyBalances}from'../../wallet/hooks';import{Bound,Field,setFullRange,typeInput,typeLeftRangeInput,typeRightRangeInput,typeStartPriceInput}from'./actions';import{tryParseTick}from'./utils';import{jsx as _jsx}from\"react/jsx-runtime\";export function useV3MintState(){return useAppSelector(function(state){return state.mintV3;});}export function useV3MintActionHandlers(noLiquidity){var dispatch=useAppDispatch();var onFieldAInput=useCallback(function(typedValue){dispatch(typeInput({field:Field.CURRENCY_A,typedValue:typedValue,noLiquidity:noLiquidity===true}));},[dispatch,noLiquidity]);var onFieldBInput=useCallback(function(typedValue){dispatch(typeInput({field:Field.CURRENCY_B,typedValue:typedValue,noLiquidity:noLiquidity===true}));},[dispatch,noLiquidity]);var onLeftRangeInput=useCallback(function(typedValue){dispatch(typeLeftRangeInput({typedValue:typedValue}));},[dispatch]);var onRightRangeInput=useCallback(function(typedValue){dispatch(typeRightRangeInput({typedValue:typedValue}));},[dispatch]);var onStartPriceInput=useCallback(function(typedValue){dispatch(typeStartPriceInput({typedValue:typedValue}));},[dispatch]);return{onFieldAInput:onFieldAInput,onFieldBInput:onFieldBInput,onLeftRangeInput:onLeftRangeInput,onRightRangeInput:onRightRangeInput,onStartPriceInput:onStartPriceInput};}export function useV3DerivedMintInfo(currencyA,currencyB,feeAmount,baseCurrency,// override for existing position\nexistingPosition){var _currencyBalances,_currencyBalances$Fie,_currencyBalances$Fie2;var _useActiveWeb3React=useActiveWeb3React(),account=_useActiveWeb3React.account;var _useV3MintState=useV3MintState(),independentField=_useV3MintState.independentField,typedValue=_useV3MintState.typedValue,leftRangeTypedValue=_useV3MintState.leftRangeTypedValue,rightRangeTypedValue=_useV3MintState.rightRangeTypedValue,startPriceTypedValue=_useV3MintState.startPriceTypedValue;var dependentField=independentField===Field.CURRENCY_A?Field.CURRENCY_B:Field.CURRENCY_A;// currencies\nvar currencies=useMemo(function(){var _ref;return _ref={},_defineProperty(_ref,Field.CURRENCY_A,currencyA),_defineProperty(_ref,Field.CURRENCY_B,currencyB),_ref;},[currencyA,currencyB]);// formatted with tokens\nvar _useMemo=useMemo(function(){return[currencyA===null||currencyA===void 0?void 0:currencyA.wrapped,currencyB===null||currencyB===void 0?void 0:currencyB.wrapped,baseCurrency===null||baseCurrency===void 0?void 0:baseCurrency.wrapped];},[currencyA,currencyB,baseCurrency]),_useMemo2=_slicedToArray(_useMemo,3),tokenA=_useMemo2[0],tokenB=_useMemo2[1],baseToken=_useMemo2[2];var _useMemo3=useMemo(function(){return tokenA&&tokenB?tokenA.sortsBefore(tokenB)?[tokenA,tokenB]:[tokenB,tokenA]:[undefined,undefined];},[tokenA,tokenB]),_useMemo4=_slicedToArray(_useMemo3,2),token0=_useMemo4[0],token1=_useMemo4[1];// balances\nvar balances=useCurrencyBalances(account!==null&&account!==void 0?account:undefined,useMemo(function(){return[currencies[Field.CURRENCY_A],currencies[Field.CURRENCY_B]];},[currencies]));var currencyBalances=(_currencyBalances={},_defineProperty(_currencyBalances,Field.CURRENCY_A,balances[0]),_defineProperty(_currencyBalances,Field.CURRENCY_B,balances[1]),_currencyBalances);// pool\nvar _usePool=usePool(currencies[Field.CURRENCY_A],currencies[Field.CURRENCY_B],feeAmount),_usePool2=_slicedToArray(_usePool,2),poolState=_usePool2[0],pool=_usePool2[1];var noLiquidity=poolState===PoolState.NOT_EXISTS;// note to parse inputs in reverse\nvar invertPrice=Boolean(baseToken&&token0&&!baseToken.equals(token0));// always returns the price with 0 as base token\nvar price=useMemo(function(){// if no liquidity use typed value\nif(noLiquidity){var parsedQuoteAmount=tryParseAmount(startPriceTypedValue,invertPrice?token0:token1);if(parsedQuoteAmount&&token0&&token1){var _ref2;var baseAmount=tryParseAmount('1',invertPrice?token1:token0);var _price=baseAmount&&parsedQuoteAmount?new Price(baseAmount.currency,parsedQuoteAmount.currency,baseAmount.quotient,parsedQuoteAmount.quotient):undefined;return(_ref2=invertPrice?_price===null||_price===void 0?void 0:_price.invert():_price)!==null&&_ref2!==void 0?_ref2:undefined;}return undefined;}else{// get the amount of quote currency\nreturn pool&&token0?pool.priceOf(token0):undefined;}},[noLiquidity,startPriceTypedValue,invertPrice,token1,token0,pool]);// check for invalid price input (converts to invalid ratio)\nvar invalidPrice=useMemo(function(){var sqrtRatioX96=price?encodeSqrtRatioX96(price.numerator,price.denominator):undefined;return price&&sqrtRatioX96&&!(JSBI.greaterThanOrEqual(sqrtRatioX96,TickMath.MIN_SQRT_RATIO)&&JSBI.lessThan(sqrtRatioX96,TickMath.MAX_SQRT_RATIO));},[price]);// used for ratio calculation when pool not initialized\nvar mockPool=useMemo(function(){if(tokenA&&tokenB&&feeAmount&&price&&!invalidPrice){var currentTick=priceToClosestTick(price);var currentSqrt=TickMath.getSqrtRatioAtTick(currentTick);return new Pool(tokenA,tokenB,feeAmount,currentSqrt,JSBI.BigInt(0),currentTick,[]);}else{return undefined;}},[feeAmount,invalidPrice,price,tokenA,tokenB]);// if pool exists use it, if not use the mock pool\nvar poolForPosition=pool!==null&&pool!==void 0?pool:mockPool;// lower and upper limits in the tick space for `feeAmoun<Trans>\nvar tickSpaceLimits=useMemo(function(){var _ref3;return _ref3={},_defineProperty(_ref3,Bound.LOWER,feeAmount?nearestUsableTick(TickMath.MIN_TICK,TICK_SPACINGS[feeAmount]):undefined),_defineProperty(_ref3,Bound.UPPER,feeAmount?nearestUsableTick(TickMath.MAX_TICK,TICK_SPACINGS[feeAmount]):undefined),_ref3;},[feeAmount]);// parse typed range values and determine closest ticks\n// lower should always be a smaller tick\nvar ticks=useMemo(function(){var _ref4;return _ref4={},_defineProperty(_ref4,Bound.LOWER,typeof(existingPosition===null||existingPosition===void 0?void 0:existingPosition.tickLower)==='number'?existingPosition.tickLower:invertPrice&&typeof rightRangeTypedValue==='boolean'||!invertPrice&&typeof leftRangeTypedValue==='boolean'?tickSpaceLimits[Bound.LOWER]:invertPrice?tryParseTick(token1,token0,feeAmount,rightRangeTypedValue.toString()):tryParseTick(token0,token1,feeAmount,leftRangeTypedValue.toString())),_defineProperty(_ref4,Bound.UPPER,typeof(existingPosition===null||existingPosition===void 0?void 0:existingPosition.tickUpper)==='number'?existingPosition.tickUpper:!invertPrice&&typeof rightRangeTypedValue==='boolean'||invertPrice&&typeof leftRangeTypedValue==='boolean'?tickSpaceLimits[Bound.UPPER]:invertPrice?tryParseTick(token1,token0,feeAmount,leftRangeTypedValue.toString()):tryParseTick(token0,token1,feeAmount,rightRangeTypedValue.toString())),_ref4;},[existingPosition,feeAmount,invertPrice,leftRangeTypedValue,rightRangeTypedValue,token0,token1,tickSpaceLimits]);var _ref5=ticks||{},tickLower=_ref5[Bound.LOWER],tickUpper=_ref5[Bound.UPPER];// specifies whether the lower and upper ticks is at the exteme bounds\nvar ticksAtLimit=useMemo(function(){var _ref6;return _ref6={},_defineProperty(_ref6,Bound.LOWER,feeAmount&&tickLower===tickSpaceLimits.LOWER),_defineProperty(_ref6,Bound.UPPER,feeAmount&&tickUpper===tickSpaceLimits.UPPER),_ref6;},[tickSpaceLimits,tickLower,tickUpper,feeAmount]);// mark invalid range\nvar invalidRange=Boolean(typeof tickLower==='number'&&typeof tickUpper==='number'&&tickLower>=tickUpper);// always returns the price with 0 as base token\nvar pricesAtTicks=useMemo(function(){var _ref7;return _ref7={},_defineProperty(_ref7,Bound.LOWER,getTickToPrice(token0,token1,ticks[Bound.LOWER])),_defineProperty(_ref7,Bound.UPPER,getTickToPrice(token0,token1,ticks[Bound.UPPER])),_ref7;},[token0,token1,ticks]);var lowerPrice=pricesAtTicks[Bound.LOWER],upperPrice=pricesAtTicks[Bound.UPPER];// liquidity range warning\nvar outOfRange=Boolean(!invalidRange&&price&&lowerPrice&&upperPrice&&(price.lessThan(lowerPrice)||price.greaterThan(upperPrice)));// amounts\nvar independentAmount=tryParseAmount(typedValue,currencies[independentField]);var dependentAmount=useMemo(function(){// we wrap the currencies just to get the price in terms of the other token\nvar wrappedIndependentAmount=independentAmount===null||independentAmount===void 0?void 0:independentAmount.wrapped;var dependentCurrency=dependentField===Field.CURRENCY_B?currencyB:currencyA;if(independentAmount&&wrappedIndependentAmount&&typeof tickLower==='number'&&typeof tickUpper==='number'&&poolForPosition){// if price is out of range or invalid range - return 0 (single deposit will be independent)\nif(outOfRange||invalidRange){return undefined;}var _position=wrappedIndependentAmount.currency.equals(poolForPosition.token0)?Position.fromAmount0({pool:poolForPosition,tickLower:tickLower,tickUpper:tickUpper,amount0:independentAmount.quotient,useFullPrecision:true// we want full precision for the theoretical position\n}):Position.fromAmount1({pool:poolForPosition,tickLower:tickLower,tickUpper:tickUpper,amount1:independentAmount.quotient});var dependentTokenAmount=wrappedIndependentAmount.currency.equals(poolForPosition.token0)?_position.amount1:_position.amount0;return dependentCurrency&&CurrencyAmount.fromRawAmount(dependentCurrency,dependentTokenAmount.quotient);}return undefined;},[independentAmount,outOfRange,dependentField,currencyB,currencyA,tickLower,tickUpper,poolForPosition,invalidRange]);var parsedAmounts=useMemo(function(){var _ref8;return _ref8={},_defineProperty(_ref8,Field.CURRENCY_A,independentField===Field.CURRENCY_A?independentAmount:dependentAmount),_defineProperty(_ref8,Field.CURRENCY_B,independentField===Field.CURRENCY_A?dependentAmount:independentAmount),_ref8;},[dependentAmount,independentAmount,independentField]);// single deposit only if price is out of range\nvar deposit0Disabled=Boolean(typeof tickUpper==='number'&&poolForPosition&&poolForPosition.tickCurrent>=tickUpper);var deposit1Disabled=Boolean(typeof tickLower==='number'&&poolForPosition&&poolForPosition.tickCurrent<=tickLower);// sorted for token order\nvar depositADisabled=invalidRange||Boolean(deposit0Disabled&&poolForPosition&&tokenA&&poolForPosition.token0.equals(tokenA)||deposit1Disabled&&poolForPosition&&tokenA&&poolForPosition.token1.equals(tokenA));var depositBDisabled=invalidRange||Boolean(deposit0Disabled&&poolForPosition&&tokenB&&poolForPosition.token0.equals(tokenB)||deposit1Disabled&&poolForPosition&&tokenB&&poolForPosition.token1.equals(tokenB));// create position entity based on users selection\nvar position=useMemo(function(){var _parsedAmounts,_parsedAmounts2;if(!poolForPosition||!tokenA||!tokenB||typeof tickLower!=='number'||typeof tickUpper!=='number'||invalidRange){return undefined;}// mark as 0 if disabled because out of range\nvar amount0=!deposit0Disabled?parsedAmounts===null||parsedAmounts===void 0?void 0:(_parsedAmounts=parsedAmounts[tokenA.equals(poolForPosition.token0)?Field.CURRENCY_A:Field.CURRENCY_B])===null||_parsedAmounts===void 0?void 0:_parsedAmounts.quotient:BIG_INT_ZERO;var amount1=!deposit1Disabled?parsedAmounts===null||parsedAmounts===void 0?void 0:(_parsedAmounts2=parsedAmounts[tokenA.equals(poolForPosition.token0)?Field.CURRENCY_B:Field.CURRENCY_A])===null||_parsedAmounts2===void 0?void 0:_parsedAmounts2.quotient:BIG_INT_ZERO;if(amount0!==undefined&&amount1!==undefined){return Position.fromAmounts({pool:poolForPosition,tickLower:tickLower,tickUpper:tickUpper,amount0:amount0,amount1:amount1,useFullPrecision:true// we want full precision for the theoretical position\n});}else{return undefined;}},[parsedAmounts,poolForPosition,tokenA,tokenB,deposit0Disabled,deposit1Disabled,invalidRange,tickLower,tickUpper]);var errorMessage;if(!account){errorMessage=/*#__PURE__*/_jsx(Trans,{id:\"Connect Wallet\"});}if(poolState===PoolState.INVALID){var _errorMessage;errorMessage=(_errorMessage=errorMessage)!==null&&_errorMessage!==void 0?_errorMessage:/*#__PURE__*/_jsx(Trans,{id:\"Invalid pair\"});}if(invalidPrice){var _errorMessage2;errorMessage=(_errorMessage2=errorMessage)!==null&&_errorMessage2!==void 0?_errorMessage2:/*#__PURE__*/_jsx(Trans,{id:\"Invalid price input\"});}if(!parsedAmounts[Field.CURRENCY_A]&&!depositADisabled||!parsedAmounts[Field.CURRENCY_B]&&!depositBDisabled){var _errorMessage3;errorMessage=(_errorMessage3=errorMessage)!==null&&_errorMessage3!==void 0?_errorMessage3:/*#__PURE__*/_jsx(Trans,{id:\"Enter an amount\"});}var currencyAAmount=parsedAmounts[Field.CURRENCY_A],currencyBAmount=parsedAmounts[Field.CURRENCY_B];if(currencyAAmount&&(currencyBalances===null||currencyBalances===void 0?void 0:(_currencyBalances$Fie=currencyBalances[Field.CURRENCY_A])===null||_currencyBalances$Fie===void 0?void 0:_currencyBalances$Fie.lessThan(currencyAAmount))){var _currencies$Field$CUR;errorMessage=/*#__PURE__*/_jsx(Trans,{id:\"Insufficient {0} balance\",values:{0:(_currencies$Field$CUR=currencies[Field.CURRENCY_A])===null||_currencies$Field$CUR===void 0?void 0:_currencies$Field$CUR.symbol}});}if(currencyBAmount&&(currencyBalances===null||currencyBalances===void 0?void 0:(_currencyBalances$Fie2=currencyBalances[Field.CURRENCY_B])===null||_currencyBalances$Fie2===void 0?void 0:_currencyBalances$Fie2.lessThan(currencyBAmount))){var _currencies$Field$CUR2;errorMessage=/*#__PURE__*/_jsx(Trans,{id:\"Insufficient {0} balance\",values:{0:(_currencies$Field$CUR2=currencies[Field.CURRENCY_B])===null||_currencies$Field$CUR2===void 0?void 0:_currencies$Field$CUR2.symbol}});}var invalidPool=poolState===PoolState.INVALID;return{dependentField:dependentField,currencies:currencies,pool:pool,poolState:poolState,currencyBalances:currencyBalances,parsedAmounts:parsedAmounts,ticks:ticks,price:price,pricesAtTicks:pricesAtTicks,position:position,noLiquidity:noLiquidity,errorMessage:errorMessage,invalidPool:invalidPool,invalidRange:invalidRange,outOfRange:outOfRange,depositADisabled:depositADisabled,depositBDisabled:depositBDisabled,invertPrice:invertPrice,ticksAtLimit:ticksAtLimit};}export function useRangeHopCallbacks(baseCurrency,quoteCurrency,feeAmount,tickLower,tickUpper,pool){var dispatch=useAppDispatch();var baseToken=useMemo(function(){return baseCurrency===null||baseCurrency===void 0?void 0:baseCurrency.wrapped;},[baseCurrency]);var quoteToken=useMemo(function(){return quoteCurrency===null||quoteCurrency===void 0?void 0:quoteCurrency.wrapped;},[quoteCurrency]);var getDecrementLower=useCallback(function(){if(baseToken&&quoteToken&&typeof tickLower==='number'&&feeAmount){var newPrice=tickToPrice(baseToken,quoteToken,tickLower-TICK_SPACINGS[feeAmount]);return newPrice.toSignificant(5,undefined,Rounding.ROUND_UP);}// use pool current tick as starting tick if we have pool but no tick input\nif(!(typeof tickLower==='number')&&baseToken&&quoteToken&&feeAmount&&pool){var _newPrice=tickToPrice(baseToken,quoteToken,pool.tickCurrent-TICK_SPACINGS[feeAmount]);return _newPrice.toSignificant(5,undefined,Rounding.ROUND_UP);}return'';},[baseToken,quoteToken,tickLower,feeAmount,pool]);var getIncrementLower=useCallback(function(){if(baseToken&&quoteToken&&typeof tickLower==='number'&&feeAmount){var newPrice=tickToPrice(baseToken,quoteToken,tickLower+TICK_SPACINGS[feeAmount]);return newPrice.toSignificant(5,undefined,Rounding.ROUND_UP);}// use pool current tick as starting tick if we have pool but no tick input\nif(!(typeof tickLower==='number')&&baseToken&&quoteToken&&feeAmount&&pool){var _newPrice2=tickToPrice(baseToken,quoteToken,pool.tickCurrent+TICK_SPACINGS[feeAmount]);return _newPrice2.toSignificant(5,undefined,Rounding.ROUND_UP);}return'';},[baseToken,quoteToken,tickLower,feeAmount,pool]);var getDecrementUpper=useCallback(function(){if(baseToken&&quoteToken&&typeof tickUpper==='number'&&feeAmount){var newPrice=tickToPrice(baseToken,quoteToken,tickUpper-TICK_SPACINGS[feeAmount]);return newPrice.toSignificant(5,undefined,Rounding.ROUND_UP);}// use pool current tick as starting tick if we have pool but no tick input\nif(!(typeof tickUpper==='number')&&baseToken&&quoteToken&&feeAmount&&pool){var _newPrice3=tickToPrice(baseToken,quoteToken,pool.tickCurrent-TICK_SPACINGS[feeAmount]);return _newPrice3.toSignificant(5,undefined,Rounding.ROUND_UP);}return'';},[baseToken,quoteToken,tickUpper,feeAmount,pool]);var getIncrementUpper=useCallback(function(){if(baseToken&&quoteToken&&typeof tickUpper==='number'&&feeAmount){var newPrice=tickToPrice(baseToken,quoteToken,tickUpper+TICK_SPACINGS[feeAmount]);return newPrice.toSignificant(5,undefined,Rounding.ROUND_UP);}// use pool current tick as starting tick if we have pool but no tick input\nif(!(typeof tickUpper==='number')&&baseToken&&quoteToken&&feeAmount&&pool){var _newPrice4=tickToPrice(baseToken,quoteToken,pool.tickCurrent+TICK_SPACINGS[feeAmount]);return _newPrice4.toSignificant(5,undefined,Rounding.ROUND_UP);}return'';},[baseToken,quoteToken,tickUpper,feeAmount,pool]);var getSetFullRange=useCallback(function(){dispatch(setFullRange());},[dispatch]);return{getDecrementLower:getDecrementLower,getIncrementLower:getIncrementLower,getDecrementUpper:getDecrementUpper,getIncrementUpper:getIncrementUpper,getSetFullRange:getSetFullRange};}","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/state/mint/v3/hooks.tsx"],"names":["CurrencyAmount","Price","Rounding","encodeSqrtRatioX96","nearestUsableTick","Pool","Position","priceToClosestTick","TICK_SPACINGS","TickMath","tickToPrice","usePool","JSBI","useCallback","useMemo","useAppDispatch","useAppSelector","getTickToPrice","BIG_INT_ZERO","PoolState","useActiveWeb3React","tryParseAmount","useCurrencyBalances","Bound","Field","setFullRange","typeInput","typeLeftRangeInput","typeRightRangeInput","typeStartPriceInput","tryParseTick","useV3MintState","state","mintV3","useV3MintActionHandlers","noLiquidity","dispatch","onFieldAInput","typedValue","field","CURRENCY_A","onFieldBInput","CURRENCY_B","onLeftRangeInput","onRightRangeInput","onStartPriceInput","useV3DerivedMintInfo","currencyA","currencyB","feeAmount","baseCurrency","existingPosition","account","independentField","leftRangeTypedValue","rightRangeTypedValue","startPriceTypedValue","dependentField","currencies","wrapped","tokenA","tokenB","baseToken","sortsBefore","undefined","token0","token1","balances","currencyBalances","poolState","pool","NOT_EXISTS","invertPrice","Boolean","equals","price","parsedQuoteAmount","baseAmount","currency","quotient","invert","priceOf","invalidPrice","sqrtRatioX96","numerator","denominator","greaterThanOrEqual","MIN_SQRT_RATIO","lessThan","MAX_SQRT_RATIO","mockPool","currentTick","currentSqrt","getSqrtRatioAtTick","BigInt","poolForPosition","tickSpaceLimits","LOWER","MIN_TICK","UPPER","MAX_TICK","ticks","tickLower","toString","tickUpper","ticksAtLimit","invalidRange","pricesAtTicks","lowerPrice","upperPrice","outOfRange","greaterThan","independentAmount","dependentAmount","wrappedIndependentAmount","dependentCurrency","position","fromAmount0","amount0","useFullPrecision","fromAmount1","amount1","dependentTokenAmount","fromRawAmount","parsedAmounts","deposit0Disabled","tickCurrent","deposit1Disabled","depositADisabled","depositBDisabled","fromAmounts","errorMessage","INVALID","currencyAAmount","currencyBAmount","symbol","invalidPool","useRangeHopCallbacks","quoteCurrency","quoteToken","getDecrementLower","newPrice","toSignificant","ROUND_UP","getIncrementLower","getDecrementUpper","getIncrementUpper","getSetFullRange"],"mappings":"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","sourcesContent":["import { Trans } from '@lingui/macro'\nimport { Currency, CurrencyAmount, Price, Rounding, Token } from '@uniswap/sdk-core'\nimport {\n  encodeSqrtRatioX96,\n  FeeAmount,\n  nearestUsableTick,\n  Pool,\n  Position,\n  priceToClosestTick,\n  TICK_SPACINGS,\n  TickMath,\n  tickToPrice,\n} from '@uniswap/v3-sdk'\nimport { usePool } from 'hooks/usePools'\nimport JSBI from 'jsbi'\nimport { ReactNode, useCallback, useMemo } from 'react'\nimport { useAppDispatch, useAppSelector } from 'state/hooks'\nimport { getTickToPrice } from 'utils/getTickToPrice'\n\nimport { BIG_INT_ZERO } from '../../../constants/misc'\nimport { PoolState } from '../../../hooks/usePools'\nimport { useActiveWeb3React } from '../../../hooks/web3'\nimport { AppState } from '../../index'\nimport { tryParseAmount } from '../../swap/hooks'\nimport { useCurrencyBalances } from '../../wallet/hooks'\nimport {\n  Bound,\n  Field,\n  setFullRange,\n  typeInput,\n  typeLeftRangeInput,\n  typeRightRangeInput,\n  typeStartPriceInput,\n} from './actions'\nimport { tryParseTick } from './utils'\n\nexport function useV3MintState(): AppState['mintV3'] {\n  return useAppSelector((state) => state.mintV3)\n}\n\nexport function useV3MintActionHandlers(noLiquidity: boolean | undefined): {\n  onFieldAInput: (typedValue: string) => void\n  onFieldBInput: (typedValue: string) => void\n  onLeftRangeInput: (typedValue: string) => void\n  onRightRangeInput: (typedValue: string) => void\n  onStartPriceInput: (typedValue: string) => void\n} {\n  const dispatch = useAppDispatch()\n\n  const onFieldAInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_A, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity]\n  )\n\n  const onFieldBInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_B, typedValue, noLiquidity: noLiquidity === true }))\n    },\n    [dispatch, noLiquidity]\n  )\n\n  const onLeftRangeInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeLeftRangeInput({ typedValue }))\n    },\n    [dispatch]\n  )\n\n  const onRightRangeInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeRightRangeInput({ typedValue }))\n    },\n    [dispatch]\n  )\n\n  const onStartPriceInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeStartPriceInput({ typedValue }))\n    },\n    [dispatch]\n  )\n\n  return {\n    onFieldAInput,\n    onFieldBInput,\n    onLeftRangeInput,\n    onRightRangeInput,\n    onStartPriceInput,\n  }\n}\n\nexport function useV3DerivedMintInfo(\n  currencyA?: Currency,\n  currencyB?: Currency,\n  feeAmount?: FeeAmount,\n  baseCurrency?: Currency,\n  // override for existing position\n  existingPosition?: Position\n): {\n  pool?: Pool | null\n  poolState: PoolState\n  ticks: { [bound in Bound]?: number | undefined }\n  price?: Price<Token, Token>\n  pricesAtTicks: {\n    [bound in Bound]?: Price<Token, Token> | undefined\n  }\n  currencies: { [field in Field]?: Currency }\n  currencyBalances: { [field in Field]?: CurrencyAmount<Currency> }\n  dependentField: Field\n  parsedAmounts: { [field in Field]?: CurrencyAmount<Currency> }\n  position: Position | undefined\n  noLiquidity?: boolean\n  errorMessage?: ReactNode\n  invalidPool: boolean\n  outOfRange: boolean\n  invalidRange: boolean\n  depositADisabled: boolean\n  depositBDisabled: boolean\n  invertPrice: boolean\n  ticksAtLimit: { [bound in Bound]?: boolean | undefined }\n} {\n  const { account } = useActiveWeb3React()\n\n  const { independentField, typedValue, leftRangeTypedValue, rightRangeTypedValue, startPriceTypedValue } =\n    useV3MintState()\n\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A\n\n  // currencies\n  const currencies: { [field in Field]?: Currency } = useMemo(\n    () => ({\n      [Field.CURRENCY_A]: currencyA,\n      [Field.CURRENCY_B]: currencyB,\n    }),\n    [currencyA, currencyB]\n  )\n\n  // formatted with tokens\n  const [tokenA, tokenB, baseToken] = useMemo(\n    () => [currencyA?.wrapped, currencyB?.wrapped, baseCurrency?.wrapped],\n    [currencyA, currencyB, baseCurrency]\n  )\n\n  const [token0, token1] = useMemo(\n    () =>\n      tokenA && tokenB ? (tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]) : [undefined, undefined],\n    [tokenA, tokenB]\n  )\n\n  // balances\n  const balances = useCurrencyBalances(\n    account ?? undefined,\n    useMemo(() => [currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]], [currencies])\n  )\n  const currencyBalances: { [field in Field]?: CurrencyAmount<Currency> } = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1],\n  }\n\n  // pool\n  const [poolState, pool] = usePool(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B], feeAmount)\n  const noLiquidity = poolState === PoolState.NOT_EXISTS\n\n  // note to parse inputs in reverse\n  const invertPrice = Boolean(baseToken && token0 && !baseToken.equals(token0))\n\n  // always returns the price with 0 as base token\n  const price: Price<Token, Token> | undefined = useMemo(() => {\n    // if no liquidity use typed value\n    if (noLiquidity) {\n      const parsedQuoteAmount = tryParseAmount(startPriceTypedValue, invertPrice ? token0 : token1)\n      if (parsedQuoteAmount && token0 && token1) {\n        const baseAmount = tryParseAmount('1', invertPrice ? token1 : token0)\n        const price =\n          baseAmount && parsedQuoteAmount\n            ? new Price(\n                baseAmount.currency,\n                parsedQuoteAmount.currency,\n                baseAmount.quotient,\n                parsedQuoteAmount.quotient\n              )\n            : undefined\n        return (invertPrice ? price?.invert() : price) ?? undefined\n      }\n      return undefined\n    } else {\n      // get the amount of quote currency\n      return pool && token0 ? pool.priceOf(token0) : undefined\n    }\n  }, [noLiquidity, startPriceTypedValue, invertPrice, token1, token0, pool])\n\n  // check for invalid price input (converts to invalid ratio)\n  const invalidPrice = useMemo(() => {\n    const sqrtRatioX96 = price ? encodeSqrtRatioX96(price.numerator, price.denominator) : undefined\n    return (\n      price &&\n      sqrtRatioX96 &&\n      !(\n        JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO) &&\n        JSBI.lessThan(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)\n      )\n    )\n  }, [price])\n\n  // used for ratio calculation when pool not initialized\n  const mockPool = useMemo(() => {\n    if (tokenA && tokenB && feeAmount && price && !invalidPrice) {\n      const currentTick = priceToClosestTick(price)\n      const currentSqrt = TickMath.getSqrtRatioAtTick(currentTick)\n      return new Pool(tokenA, tokenB, feeAmount, currentSqrt, JSBI.BigInt(0), currentTick, [])\n    } else {\n      return undefined\n    }\n  }, [feeAmount, invalidPrice, price, tokenA, tokenB])\n\n  // if pool exists use it, if not use the mock pool\n  const poolForPosition: Pool | undefined = pool ?? mockPool\n\n  // lower and upper limits in the tick space for `feeAmoun<Trans>\n  const tickSpaceLimits: {\n    [bound in Bound]: number | undefined\n  } = useMemo(\n    () => ({\n      [Bound.LOWER]: feeAmount ? nearestUsableTick(TickMath.MIN_TICK, TICK_SPACINGS[feeAmount]) : undefined,\n      [Bound.UPPER]: feeAmount ? nearestUsableTick(TickMath.MAX_TICK, TICK_SPACINGS[feeAmount]) : undefined,\n    }),\n    [feeAmount]\n  )\n\n  // parse typed range values and determine closest ticks\n  // lower should always be a smaller tick\n  const ticks: {\n    [key: string]: number | undefined\n  } = useMemo(() => {\n    return {\n      [Bound.LOWER]:\n        typeof existingPosition?.tickLower === 'number'\n          ? existingPosition.tickLower\n          : (invertPrice && typeof rightRangeTypedValue === 'boolean') ||\n            (!invertPrice && typeof leftRangeTypedValue === 'boolean')\n          ? tickSpaceLimits[Bound.LOWER]\n          : invertPrice\n          ? tryParseTick(token1, token0, feeAmount, rightRangeTypedValue.toString())\n          : tryParseTick(token0, token1, feeAmount, leftRangeTypedValue.toString()),\n      [Bound.UPPER]:\n        typeof existingPosition?.tickUpper === 'number'\n          ? existingPosition.tickUpper\n          : (!invertPrice && typeof rightRangeTypedValue === 'boolean') ||\n            (invertPrice && typeof leftRangeTypedValue === 'boolean')\n          ? tickSpaceLimits[Bound.UPPER]\n          : invertPrice\n          ? tryParseTick(token1, token0, feeAmount, leftRangeTypedValue.toString())\n          : tryParseTick(token0, token1, feeAmount, rightRangeTypedValue.toString()),\n    }\n  }, [\n    existingPosition,\n    feeAmount,\n    invertPrice,\n    leftRangeTypedValue,\n    rightRangeTypedValue,\n    token0,\n    token1,\n    tickSpaceLimits,\n  ])\n\n  const { [Bound.LOWER]: tickLower, [Bound.UPPER]: tickUpper } = ticks || {}\n\n  // specifies whether the lower and upper ticks is at the exteme bounds\n  const ticksAtLimit = useMemo(\n    () => ({\n      [Bound.LOWER]: feeAmount && tickLower === tickSpaceLimits.LOWER,\n      [Bound.UPPER]: feeAmount && tickUpper === tickSpaceLimits.UPPER,\n    }),\n    [tickSpaceLimits, tickLower, tickUpper, feeAmount]\n  )\n\n  // mark invalid range\n  const invalidRange = Boolean(typeof tickLower === 'number' && typeof tickUpper === 'number' && tickLower >= tickUpper)\n\n  // always returns the price with 0 as base token\n  const pricesAtTicks = useMemo(() => {\n    return {\n      [Bound.LOWER]: getTickToPrice(token0, token1, ticks[Bound.LOWER]),\n      [Bound.UPPER]: getTickToPrice(token0, token1, ticks[Bound.UPPER]),\n    }\n  }, [token0, token1, ticks])\n  const { [Bound.LOWER]: lowerPrice, [Bound.UPPER]: upperPrice } = pricesAtTicks\n\n  // liquidity range warning\n  const outOfRange = Boolean(\n    !invalidRange && price && lowerPrice && upperPrice && (price.lessThan(lowerPrice) || price.greaterThan(upperPrice))\n  )\n\n  // amounts\n  const independentAmount: CurrencyAmount<Currency> | undefined = tryParseAmount(\n    typedValue,\n    currencies[independentField]\n  )\n\n  const dependentAmount: CurrencyAmount<Currency> | undefined = useMemo(() => {\n    // we wrap the currencies just to get the price in terms of the other token\n    const wrappedIndependentAmount = independentAmount?.wrapped\n    const dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA\n    if (\n      independentAmount &&\n      wrappedIndependentAmount &&\n      typeof tickLower === 'number' &&\n      typeof tickUpper === 'number' &&\n      poolForPosition\n    ) {\n      // if price is out of range or invalid range - return 0 (single deposit will be independent)\n      if (outOfRange || invalidRange) {\n        return undefined\n      }\n\n      const position: Position | undefined = wrappedIndependentAmount.currency.equals(poolForPosition.token0)\n        ? Position.fromAmount0({\n            pool: poolForPosition,\n            tickLower,\n            tickUpper,\n            amount0: independentAmount.quotient,\n            useFullPrecision: true, // we want full precision for the theoretical position\n          })\n        : Position.fromAmount1({\n            pool: poolForPosition,\n            tickLower,\n            tickUpper,\n            amount1: independentAmount.quotient,\n          })\n\n      const dependentTokenAmount = wrappedIndependentAmount.currency.equals(poolForPosition.token0)\n        ? position.amount1\n        : position.amount0\n      return dependentCurrency && CurrencyAmount.fromRawAmount(dependentCurrency, dependentTokenAmount.quotient)\n    }\n\n    return undefined\n  }, [\n    independentAmount,\n    outOfRange,\n    dependentField,\n    currencyB,\n    currencyA,\n    tickLower,\n    tickUpper,\n    poolForPosition,\n    invalidRange,\n  ])\n\n  const parsedAmounts: { [field in Field]: CurrencyAmount<Currency> | undefined } = useMemo(() => {\n    return {\n      [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n      [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount,\n    }\n  }, [dependentAmount, independentAmount, independentField])\n\n  // single deposit only if price is out of range\n  const deposit0Disabled = Boolean(\n    typeof tickUpper === 'number' && poolForPosition && poolForPosition.tickCurrent >= tickUpper\n  )\n  const deposit1Disabled = Boolean(\n    typeof tickLower === 'number' && poolForPosition && poolForPosition.tickCurrent <= tickLower\n  )\n\n  // sorted for token order\n  const depositADisabled =\n    invalidRange ||\n    Boolean(\n      (deposit0Disabled && poolForPosition && tokenA && poolForPosition.token0.equals(tokenA)) ||\n        (deposit1Disabled && poolForPosition && tokenA && poolForPosition.token1.equals(tokenA))\n    )\n  const depositBDisabled =\n    invalidRange ||\n    Boolean(\n      (deposit0Disabled && poolForPosition && tokenB && poolForPosition.token0.equals(tokenB)) ||\n        (deposit1Disabled && poolForPosition && tokenB && poolForPosition.token1.equals(tokenB))\n    )\n\n  // create position entity based on users selection\n  const position: Position | undefined = useMemo(() => {\n    if (\n      !poolForPosition ||\n      !tokenA ||\n      !tokenB ||\n      typeof tickLower !== 'number' ||\n      typeof tickUpper !== 'number' ||\n      invalidRange\n    ) {\n      return undefined\n    }\n\n    // mark as 0 if disabled because out of range\n    const amount0 = !deposit0Disabled\n      ? parsedAmounts?.[tokenA.equals(poolForPosition.token0) ? Field.CURRENCY_A : Field.CURRENCY_B]?.quotient\n      : BIG_INT_ZERO\n    const amount1 = !deposit1Disabled\n      ? parsedAmounts?.[tokenA.equals(poolForPosition.token0) ? Field.CURRENCY_B : Field.CURRENCY_A]?.quotient\n      : BIG_INT_ZERO\n\n    if (amount0 !== undefined && amount1 !== undefined) {\n      return Position.fromAmounts({\n        pool: poolForPosition,\n        tickLower,\n        tickUpper,\n        amount0,\n        amount1,\n        useFullPrecision: true, // we want full precision for the theoretical position\n      })\n    } else {\n      return undefined\n    }\n  }, [\n    parsedAmounts,\n    poolForPosition,\n    tokenA,\n    tokenB,\n    deposit0Disabled,\n    deposit1Disabled,\n    invalidRange,\n    tickLower,\n    tickUpper,\n  ])\n\n  let errorMessage: ReactNode | undefined\n  if (!account) {\n    errorMessage = <Trans>Connect Wallet</Trans>\n  }\n\n  if (poolState === PoolState.INVALID) {\n    errorMessage = errorMessage ?? <Trans>Invalid pair</Trans>\n  }\n\n  if (invalidPrice) {\n    errorMessage = errorMessage ?? <Trans>Invalid price input</Trans>\n  }\n\n  if (\n    (!parsedAmounts[Field.CURRENCY_A] && !depositADisabled) ||\n    (!parsedAmounts[Field.CURRENCY_B] && !depositBDisabled)\n  ) {\n    errorMessage = errorMessage ?? <Trans>Enter an amount</Trans>\n  }\n\n  const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts\n\n  if (currencyAAmount && currencyBalances?.[Field.CURRENCY_A]?.lessThan(currencyAAmount)) {\n    errorMessage = <Trans>Insufficient {currencies[Field.CURRENCY_A]?.symbol} balance</Trans>\n  }\n\n  if (currencyBAmount && currencyBalances?.[Field.CURRENCY_B]?.lessThan(currencyBAmount)) {\n    errorMessage = <Trans>Insufficient {currencies[Field.CURRENCY_B]?.symbol} balance</Trans>\n  }\n\n  const invalidPool = poolState === PoolState.INVALID\n\n  return {\n    dependentField,\n    currencies,\n    pool,\n    poolState,\n    currencyBalances,\n    parsedAmounts,\n    ticks,\n    price,\n    pricesAtTicks,\n    position,\n    noLiquidity,\n    errorMessage,\n    invalidPool,\n    invalidRange,\n    outOfRange,\n    depositADisabled,\n    depositBDisabled,\n    invertPrice,\n    ticksAtLimit,\n  }\n}\n\nexport function useRangeHopCallbacks(\n  baseCurrency: Currency | undefined,\n  quoteCurrency: Currency | undefined,\n  feeAmount: FeeAmount | undefined,\n  tickLower: number | undefined,\n  tickUpper: number | undefined,\n  pool?: Pool | undefined | null\n) {\n  const dispatch = useAppDispatch()\n\n  const baseToken = useMemo(() => baseCurrency?.wrapped, [baseCurrency])\n  const quoteToken = useMemo(() => quoteCurrency?.wrapped, [quoteCurrency])\n\n  const getDecrementLower = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickLower === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickLower - TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickLower === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent - TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    return ''\n  }, [baseToken, quoteToken, tickLower, feeAmount, pool])\n\n  const getIncrementLower = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickLower === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickLower + TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickLower === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent + TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    return ''\n  }, [baseToken, quoteToken, tickLower, feeAmount, pool])\n\n  const getDecrementUpper = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickUpper === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickUpper - TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickUpper === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent - TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    return ''\n  }, [baseToken, quoteToken, tickUpper, feeAmount, pool])\n\n  const getIncrementUpper = useCallback(() => {\n    if (baseToken && quoteToken && typeof tickUpper === 'number' && feeAmount) {\n      const newPrice = tickToPrice(baseToken, quoteToken, tickUpper + TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    // use pool current tick as starting tick if we have pool but no tick input\n    if (!(typeof tickUpper === 'number') && baseToken && quoteToken && feeAmount && pool) {\n      const newPrice = tickToPrice(baseToken, quoteToken, pool.tickCurrent + TICK_SPACINGS[feeAmount])\n      return newPrice.toSignificant(5, undefined, Rounding.ROUND_UP)\n    }\n    return ''\n  }, [baseToken, quoteToken, tickUpper, feeAmount, pool])\n\n  const getSetFullRange = useCallback(() => {\n    dispatch(setFullRange())\n  }, [dispatch])\n\n  return { getDecrementLower, getIncrementLower, getDecrementUpper, getIncrementUpper, getSetFullRange }\n}\n"]},"metadata":{},"sourceType":"module"}