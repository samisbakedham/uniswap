{"ast":null,"code":"import _ from 'lodash';\nimport stats from 'stats-lite';\nimport { UniswapInterfaceMulticall__factory } from '../types/v3/factories/UniswapInterfaceMulticall__factory';\nimport { ChainId } from '../util';\nimport { UNISWAP_MULTICALL_ADDRESS } from '../util/addresses';\nimport { log } from '../util/log';\nimport { IMulticallProvider } from './multicall-provider';\nconst contractAddressByChain = {\n  [ChainId.MAINNET]: UNISWAP_MULTICALL_ADDRESS,\n  [ChainId.RINKEBY]: UNISWAP_MULTICALL_ADDRESS,\n  [ChainId.KOVAN]: UNISWAP_MULTICALL_ADDRESS,\n  [ChainId.ROPSTEN]: UNISWAP_MULTICALL_ADDRESS,\n  [ChainId.GÖRLI]: UNISWAP_MULTICALL_ADDRESS\n};\n/**\n * The UniswapMulticall contract has added functionality for limiting the amount of gas\n * that each call within the multicall can consume. This is useful for operations where\n * a call could consume such a large amount of gas that it causes the node to error out\n * with an out of gas error.\n *\n * @export\n * @class UniswapMulticallProvider\n */\n\nexport class UniswapMulticallProvider extends IMulticallProvider {\n  constructor(chainId, provider, gasLimitPerCall = 1000000, multicallAddressOverride = UNISWAP_MULTICALL_ADDRESS) {\n    super();\n    this.chainId = chainId;\n    this.provider = provider;\n    this.gasLimitPerCall = gasLimitPerCall;\n    this.multicallAddressOverride = multicallAddressOverride;\n    const multicallAddress = multicallAddressOverride ? multicallAddressOverride : contractAddressByChain[this.chainId];\n\n    if (!multicallAddress) {\n      throw new Error(`No address for Uniswap Multicall Contract on chain id: ${chainId}`);\n    }\n\n    this.multicallContract = UniswapInterfaceMulticall__factory.connect(multicallAddress, this.provider);\n  }\n\n  async callSameFunctionOnMultipleContracts(params) {\n    var _a;\n\n    const {\n      addresses,\n      contractInterface,\n      functionName,\n      functionParams,\n      providerConfig\n    } = params;\n    const blockNumberOverride = (_a = providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber) !== null && _a !== void 0 ? _a : undefined;\n    const fragment = contractInterface.getFunction(functionName);\n    const callData = contractInterface.encodeFunctionData(fragment, functionParams);\n\n    const calls = _.map(addresses, address => {\n      return {\n        target: address,\n        callData,\n        gasLimit: this.gasLimitPerCall\n      };\n    });\n\n    log.debug({\n      calls\n    }, `About to multicall for ${functionName} across ${addresses.length} addresses`);\n    const {\n      blockNumber,\n      returnData: aggregateResults\n    } = await this.multicallContract.callStatic.multicall(calls, {\n      blockTag: blockNumberOverride\n    });\n    const results = [];\n\n    for (let i = 0; i < aggregateResults.length; i++) {\n      const {\n        success,\n        returnData\n      } = aggregateResults[i]; // Return data \"0x\" is sometimes returned for invalid calls.\n\n      if (!success || returnData.length <= 2) {\n        log.debug({\n          result: aggregateResults[i]\n        }, `Invalid result calling ${functionName} on address ${addresses[i]}`);\n        results.push({\n          success: false,\n          returnData\n        });\n        continue;\n      }\n\n      results.push({\n        success: true,\n        result: contractInterface.decodeFunctionResult(fragment, returnData)\n      });\n    }\n\n    log.debug({\n      results\n    }, `Results for multicall on ${functionName} across ${addresses.length} addresses as of block ${blockNumber}`);\n    return {\n      blockNumber,\n      results\n    };\n  }\n\n  async callSameFunctionOnContractWithMultipleParams(params) {\n    var _a, _b;\n\n    const {\n      address,\n      contractInterface,\n      functionName,\n      functionParams,\n      additionalConfig,\n      providerConfig\n    } = params;\n    const fragment = contractInterface.getFunction(functionName);\n    const gasLimitPerCall = (_a = additionalConfig === null || additionalConfig === void 0 ? void 0 : additionalConfig.gasLimitPerCallOverride) !== null && _a !== void 0 ? _a : this.gasLimitPerCall;\n    const blockNumberOverride = (_b = providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber) !== null && _b !== void 0 ? _b : undefined;\n\n    const calls = _.map(functionParams, functionParam => {\n      const callData = contractInterface.encodeFunctionData(fragment, functionParam);\n      return {\n        target: address,\n        callData,\n        gasLimit: gasLimitPerCall\n      };\n    });\n\n    log.debug({\n      calls\n    }, `About to multicall for ${functionName} at address ${address} with ${functionParams.length} different sets of params`);\n    const {\n      blockNumber,\n      returnData: aggregateResults\n    } = await this.multicallContract.callStatic.multicall(calls, {\n      blockTag: blockNumberOverride\n    });\n    const results = [];\n    const gasUsedForSuccess = [];\n\n    for (let i = 0; i < aggregateResults.length; i++) {\n      const {\n        success,\n        returnData,\n        gasUsed\n      } = aggregateResults[i]; // Return data \"0x\" is sometimes returned for invalid pools.\n\n      if (!success || returnData.length <= 2) {\n        log.debug({\n          result: aggregateResults[i]\n        }, `Invalid result calling ${functionName} with params ${functionParams[i]}`);\n        results.push({\n          success: false,\n          returnData\n        });\n        continue;\n      }\n\n      gasUsedForSuccess.push(gasUsed.toNumber());\n      results.push({\n        success: true,\n        result: contractInterface.decodeFunctionResult(fragment, returnData)\n      });\n    }\n\n    log.debug({\n      results,\n      functionName,\n      address\n    }, `Results for multicall for ${functionName} at address ${address} with ${functionParams.length} different sets of params. Results as of block ${blockNumber}`);\n    return {\n      blockNumber,\n      results,\n      approxGasUsedPerSuccessCall: stats.percentile(gasUsedForSuccess, 99)\n    };\n  }\n\n}","map":{"version":3,"sources":["../../../../src/providers/multicall-uniswap-provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import _ from 'lodash';\nimport stats from 'stats-lite';\nimport { UniswapInterfaceMulticall__factory } from '../types/v3/factories/UniswapInterfaceMulticall__factory';\nimport { ChainId } from '../util';\nimport { UNISWAP_MULTICALL_ADDRESS } from '../util/addresses';\nimport { log } from '../util/log';\nimport { IMulticallProvider, } from './multicall-provider';\nconst contractAddressByChain = {\n    [ChainId.MAINNET]: UNISWAP_MULTICALL_ADDRESS,\n    [ChainId.RINKEBY]: UNISWAP_MULTICALL_ADDRESS,\n    [ChainId.KOVAN]: UNISWAP_MULTICALL_ADDRESS,\n    [ChainId.ROPSTEN]: UNISWAP_MULTICALL_ADDRESS,\n    [ChainId.GÖRLI]: UNISWAP_MULTICALL_ADDRESS,\n};\n/**\n * The UniswapMulticall contract has added functionality for limiting the amount of gas\n * that each call within the multicall can consume. This is useful for operations where\n * a call could consume such a large amount of gas that it causes the node to error out\n * with an out of gas error.\n *\n * @export\n * @class UniswapMulticallProvider\n */\nexport class UniswapMulticallProvider extends IMulticallProvider {\n    constructor(chainId, provider, gasLimitPerCall = 1000000, multicallAddressOverride = UNISWAP_MULTICALL_ADDRESS) {\n        super();\n        this.chainId = chainId;\n        this.provider = provider;\n        this.gasLimitPerCall = gasLimitPerCall;\n        this.multicallAddressOverride = multicallAddressOverride;\n        const multicallAddress = multicallAddressOverride\n            ? multicallAddressOverride\n            : contractAddressByChain[this.chainId];\n        if (!multicallAddress) {\n            throw new Error(`No address for Uniswap Multicall Contract on chain id: ${chainId}`);\n        }\n        this.multicallContract = UniswapInterfaceMulticall__factory.connect(multicallAddress, this.provider);\n    }\n    async callSameFunctionOnMultipleContracts(params) {\n        var _a;\n        const { addresses, contractInterface, functionName, functionParams, providerConfig, } = params;\n        const blockNumberOverride = (_a = providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber) !== null && _a !== void 0 ? _a : undefined;\n        const fragment = contractInterface.getFunction(functionName);\n        const callData = contractInterface.encodeFunctionData(fragment, functionParams);\n        const calls = _.map(addresses, (address) => {\n            return {\n                target: address,\n                callData,\n                gasLimit: this.gasLimitPerCall,\n            };\n        });\n        log.debug({ calls }, `About to multicall for ${functionName} across ${addresses.length} addresses`);\n        const { blockNumber, returnData: aggregateResults } = await this.multicallContract.callStatic.multicall(calls, {\n            blockTag: blockNumberOverride,\n        });\n        const results = [];\n        for (let i = 0; i < aggregateResults.length; i++) {\n            const { success, returnData } = aggregateResults[i];\n            // Return data \"0x\" is sometimes returned for invalid calls.\n            if (!success || returnData.length <= 2) {\n                log.debug({ result: aggregateResults[i] }, `Invalid result calling ${functionName} on address ${addresses[i]}`);\n                results.push({\n                    success: false,\n                    returnData,\n                });\n                continue;\n            }\n            results.push({\n                success: true,\n                result: contractInterface.decodeFunctionResult(fragment, returnData),\n            });\n        }\n        log.debug({ results }, `Results for multicall on ${functionName} across ${addresses.length} addresses as of block ${blockNumber}`);\n        return { blockNumber, results };\n    }\n    async callSameFunctionOnContractWithMultipleParams(params) {\n        var _a, _b;\n        const { address, contractInterface, functionName, functionParams, additionalConfig, providerConfig, } = params;\n        const fragment = contractInterface.getFunction(functionName);\n        const gasLimitPerCall = (_a = additionalConfig === null || additionalConfig === void 0 ? void 0 : additionalConfig.gasLimitPerCallOverride) !== null && _a !== void 0 ? _a : this.gasLimitPerCall;\n        const blockNumberOverride = (_b = providerConfig === null || providerConfig === void 0 ? void 0 : providerConfig.blockNumber) !== null && _b !== void 0 ? _b : undefined;\n        const calls = _.map(functionParams, (functionParam) => {\n            const callData = contractInterface.encodeFunctionData(fragment, functionParam);\n            return {\n                target: address,\n                callData,\n                gasLimit: gasLimitPerCall,\n            };\n        });\n        log.debug({ calls }, `About to multicall for ${functionName} at address ${address} with ${functionParams.length} different sets of params`);\n        const { blockNumber, returnData: aggregateResults } = await this.multicallContract.callStatic.multicall(calls, {\n            blockTag: blockNumberOverride,\n        });\n        const results = [];\n        const gasUsedForSuccess = [];\n        for (let i = 0; i < aggregateResults.length; i++) {\n            const { success, returnData, gasUsed } = aggregateResults[i];\n            // Return data \"0x\" is sometimes returned for invalid pools.\n            if (!success || returnData.length <= 2) {\n                log.debug({ result: aggregateResults[i] }, `Invalid result calling ${functionName} with params ${functionParams[i]}`);\n                results.push({\n                    success: false,\n                    returnData,\n                });\n                continue;\n            }\n            gasUsedForSuccess.push(gasUsed.toNumber());\n            results.push({\n                success: true,\n                result: contractInterface.decodeFunctionResult(fragment, returnData),\n            });\n        }\n        log.debug({ results, functionName, address }, `Results for multicall for ${functionName} at address ${address} with ${functionParams.length} different sets of params. Results as of block ${blockNumber}`);\n        return {\n            blockNumber,\n            results,\n            approxGasUsedPerSuccessCall: stats.percentile(gasUsedForSuccess, 99),\n        };\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibXVsdGljYWxsLXVuaXN3YXAtcHJvdmlkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvcHJvdmlkZXJzL211bHRpY2FsbC11bmlzd2FwLXByb3ZpZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sQ0FBQyxNQUFNLFFBQVEsQ0FBQztBQUN2QixPQUFPLEtBQUssTUFBTSxZQUFZLENBQUM7QUFDL0IsT0FBTyxFQUFFLGtDQUFrQyxFQUFFLE1BQU0sMERBQTBELENBQUM7QUFFOUcsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUNsQyxPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUM5RCxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQ2xDLE9BQU8sRUFHTCxrQkFBa0IsR0FFbkIsTUFBTSxzQkFBc0IsQ0FBQztBQU05QixNQUFNLHNCQUFzQixHQUFzQztJQUNoRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSx5QkFBeUI7SUFDNUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUseUJBQXlCO0lBQzVDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFLHlCQUF5QjtJQUMxQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSx5QkFBeUI7SUFDNUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUUseUJBQXlCO0NBQzNDLENBQUM7QUFFRjs7Ozs7Ozs7R0FRRztBQUNILE1BQU0sT0FBTyx3QkFBeUIsU0FBUSxrQkFBMEM7SUFHdEYsWUFDWSxPQUFnQixFQUNoQixRQUFnQyxFQUNoQyxrQkFBa0IsT0FBUyxFQUMzQiwyQkFBMkIseUJBQXlCO1FBRTlELEtBQUssRUFBRSxDQUFDO1FBTEUsWUFBTyxHQUFQLE9BQU8sQ0FBUztRQUNoQixhQUFRLEdBQVIsUUFBUSxDQUF3QjtRQUNoQyxvQkFBZSxHQUFmLGVB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"]},"metadata":{},"sourceType":"module"}