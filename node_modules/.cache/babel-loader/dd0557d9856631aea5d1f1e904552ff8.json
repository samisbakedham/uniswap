{"ast":null,"code":"import _regeneratorRuntime from\"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/safahi/Downloads/interface-4.30.1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{nanoid}from'@reduxjs/toolkit';import{useCallback}from'react';import{useAppDispatch}from'state/hooks';import{getNetworkLibrary}from'../connectors';import{fetchTokenList}from'../state/lists/actions';import getTokenList from'../utils/getTokenList';import resolveENSContentHash from'../utils/resolveENSContentHash';import{useActiveWeb3React}from'./web3';export function useFetchListCallback(){var _useActiveWeb3React=useActiveWeb3React(),chainId=_useActiveWeb3React.chainId,library=_useActiveWeb3React.library;var dispatch=useAppDispatch();var ensResolver=useCallback(/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(ensName){var networkLibrary,network;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!(!library||chainId!==1)){_context.next=8;break;}networkLibrary=getNetworkLibrary();_context.next=4;return networkLibrary.getNetwork();case 4:network=_context.sent;if(!(networkLibrary&&network.chainId===1)){_context.next=7;break;}return _context.abrupt(\"return\",resolveENSContentHash(ensName,networkLibrary));case 7:throw new Error('Could not construct mainnet ENS resolver');case 8:return _context.abrupt(\"return\",resolveENSContentHash(ensName,library));case 9:case\"end\":return _context.stop();}}},_callee);}));return function(_x){return _ref.apply(this,arguments);};}(),[chainId,library]);// note: prevent dispatch if using for list search or unsupported list\nreturn useCallback(/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(listUrl){var sendDispatch,requestId,_args2=arguments;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:sendDispatch=_args2.length>1&&_args2[1]!==undefined?_args2[1]:true;requestId=nanoid();sendDispatch&&dispatch(fetchTokenList.pending({requestId:requestId,url:listUrl}));return _context2.abrupt(\"return\",getTokenList(listUrl,ensResolver).then(function(tokenList){sendDispatch&&dispatch(fetchTokenList.fulfilled({url:listUrl,tokenList:tokenList,requestId:requestId}));return tokenList;}).catch(function(error){console.debug(\"Failed to get list at url \".concat(listUrl),error);sendDispatch&&dispatch(fetchTokenList.rejected({url:listUrl,requestId:requestId,errorMessage:error.message}));throw error;}));case 4:case\"end\":return _context2.stop();}}},_callee2);}));return function(_x2){return _ref2.apply(this,arguments);};}(),[dispatch,ensResolver]);}","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/hooks/useFetchListCallback.ts"],"names":["nanoid","useCallback","useAppDispatch","getNetworkLibrary","fetchTokenList","getTokenList","resolveENSContentHash","useActiveWeb3React","useFetchListCallback","chainId","library","dispatch","ensResolver","ensName","networkLibrary","getNetwork","network","Error","listUrl","sendDispatch","requestId","pending","url","then","tokenList","fulfilled","catch","error","console","debug","rejected","errorMessage","message"],"mappings":"2TAAA,OAASA,MAAT,KAAuB,kBAAvB,CAEA,OAASC,WAAT,KAA4B,OAA5B,CACA,OAASC,cAAT,KAA+B,aAA/B,CAEA,OAASC,iBAAT,KAAkC,eAAlC,CACA,OAASC,cAAT,KAA+B,wBAA/B,CACA,MAAOC,CAAAA,YAAP,KAAyB,uBAAzB,CACA,MAAOC,CAAAA,qBAAP,KAAkC,gCAAlC,CACA,OAASC,kBAAT,KAAmC,QAAnC,CAEA,MAAO,SAASC,CAAAA,oBAAT,EAAiG,CACtG,wBAA6BD,kBAAkB,EAA/C,CAAQE,OAAR,qBAAQA,OAAR,CAAiBC,OAAjB,qBAAiBA,OAAjB,CACA,GAAMC,CAAAA,QAAQ,CAAGT,cAAc,EAA/B,CAEA,GAAMU,CAAAA,WAAW,CAAGX,WAAW,0FAC7B,iBAAOY,OAAP,kJACM,CAACH,OAAD,EAAYD,OAAO,GAAK,CAD9B,0BAEUK,cAFV,CAE2BX,iBAAiB,EAF5C,uBAG0BW,CAAAA,cAAc,CAACC,UAAf,EAH1B,QAGUC,OAHV,oBAIQF,cAAc,EAAIE,OAAO,CAACP,OAAR,GAAoB,CAJ9C,0DAKaH,qBAAqB,CAACO,OAAD,CAAUC,cAAV,CALlC,cAOU,IAAIG,CAAAA,KAAJ,CAAU,0CAAV,CAPV,wCASSX,qBAAqB,CAACO,OAAD,CAAUH,OAAV,CAT9B,wDAD6B,+DAY7B,CAACD,OAAD,CAAUC,OAAV,CAZ6B,CAA/B,CAeA;AACA,MAAOT,CAAAA,WAAW,2FAChB,kBAAOiB,OAAP,kKAAwBC,YAAxB,kDAAuC,IAAvC,CACQC,SADR,CACoBpB,MAAM,EAD1B,CAEEmB,YAAY,EAAIR,QAAQ,CAACP,cAAc,CAACiB,OAAf,CAAuB,CAAED,SAAS,CAATA,SAAF,CAAaE,GAAG,CAAEJ,OAAlB,CAAvB,CAAD,CAAxB,CAFF,iCAGSb,YAAY,CAACa,OAAD,CAAUN,WAAV,CAAZ,CACJW,IADI,CACC,SAACC,SAAD,CAAe,CACnBL,YAAY,EAAIR,QAAQ,CAACP,cAAc,CAACqB,SAAf,CAAyB,CAAEH,GAAG,CAAEJ,OAAP,CAAgBM,SAAS,CAATA,SAAhB,CAA2BJ,SAAS,CAATA,SAA3B,CAAzB,CAAD,CAAxB,CACA,MAAOI,CAAAA,SAAP,CACD,CAJI,EAKJE,KALI,CAKE,SAACC,KAAD,CAAW,CAChBC,OAAO,CAACC,KAAR,qCAA2CX,OAA3C,EAAsDS,KAAtD,EACAR,YAAY,EAAIR,QAAQ,CAACP,cAAc,CAAC0B,QAAf,CAAwB,CAAER,GAAG,CAAEJ,OAAP,CAAgBE,SAAS,CAATA,SAAhB,CAA2BW,YAAY,CAAEJ,KAAK,CAACK,OAA/C,CAAxB,CAAD,CAAxB,CACA,KAAML,CAAAA,KAAN,CACD,CATI,CAHT,0DADgB,iEAehB,CAAChB,QAAD,CAAWC,WAAX,CAfgB,CAAlB,CAiBD","sourcesContent":["import { nanoid } from '@reduxjs/toolkit'\nimport { TokenList } from '@uniswap/token-lists'\nimport { useCallback } from 'react'\nimport { useAppDispatch } from 'state/hooks'\n\nimport { getNetworkLibrary } from '../connectors'\nimport { fetchTokenList } from '../state/lists/actions'\nimport getTokenList from '../utils/getTokenList'\nimport resolveENSContentHash from '../utils/resolveENSContentHash'\nimport { useActiveWeb3React } from './web3'\n\nexport function useFetchListCallback(): (listUrl: string, sendDispatch?: boolean) => Promise<TokenList> {\n  const { chainId, library } = useActiveWeb3React()\n  const dispatch = useAppDispatch()\n\n  const ensResolver = useCallback(\n    async (ensName: string) => {\n      if (!library || chainId !== 1) {\n        const networkLibrary = getNetworkLibrary()\n        const network = await networkLibrary.getNetwork()\n        if (networkLibrary && network.chainId === 1) {\n          return resolveENSContentHash(ensName, networkLibrary)\n        }\n        throw new Error('Could not construct mainnet ENS resolver')\n      }\n      return resolveENSContentHash(ensName, library)\n    },\n    [chainId, library]\n  )\n\n  // note: prevent dispatch if using for list search or unsupported list\n  return useCallback(\n    async (listUrl: string, sendDispatch = true) => {\n      const requestId = nanoid()\n      sendDispatch && dispatch(fetchTokenList.pending({ requestId, url: listUrl }))\n      return getTokenList(listUrl, ensResolver)\n        .then((tokenList) => {\n          sendDispatch && dispatch(fetchTokenList.fulfilled({ url: listUrl, tokenList, requestId }))\n          return tokenList\n        })\n        .catch((error) => {\n          console.debug(`Failed to get list at url ${listUrl}`, error)\n          sendDispatch && dispatch(fetchTokenList.rejected({ url: listUrl, requestId, errorMessage: error.message }))\n          throw error\n        })\n    },\n    [dispatch, ensResolver]\n  )\n}\n"]},"metadata":{},"sourceType":"module"}