{"ast":null,"code":"import{useEffect,useMemo}from'react';import{useActiveWeb3React}from'../../hooks/web3';import{useBlockNumber}from'../application/hooks';import{useAppDispatch,useAppSelector}from'../hooks';import{addListener,removeListener}from'./slice';import{filterToKey}from'./utils';export var LogsState;(function(LogsState){LogsState[LogsState[\"INVALID\"]=0]=\"INVALID\";LogsState[LogsState[\"LOADING\"]=1]=\"LOADING\";LogsState[LogsState[\"SYNCING\"]=2]=\"SYNCING\";LogsState[LogsState[\"ERROR\"]=3]=\"ERROR\";LogsState[LogsState[\"SYNCED\"]=4]=\"SYNCED\";})(LogsState||(LogsState={}));/**\n * Returns the logs for the given filter as of the latest block, re-fetching from the library every block.\n * @param filter The logs filter, without `blockHash`, `fromBlock` or `toBlock` defined.\n * The filter parameter should _always_ be memoized, or else will trigger constant refetching\n */export function useLogs(filter){var _useActiveWeb3React=useActiveWeb3React(),chainId=_useActiveWeb3React.chainId;var blockNumber=useBlockNumber();var logs=useAppSelector(function(state){return state.logs;});var dispatch=useAppDispatch();useEffect(function(){if(!filter||!chainId)return;dispatch(addListener({chainId:chainId,filter:filter}));return function(){dispatch(removeListener({chainId:chainId,filter:filter}));};},[chainId,dispatch,filter]);var filterKey=useMemo(function(){return filter?filterToKey(filter):undefined;},[filter]);return useMemo(function(){var _logs$chainId;if(!chainId||!filterKey||!blockNumber)return{logs:undefined,state:LogsState.INVALID};var state=(_logs$chainId=logs[chainId])===null||_logs$chainId===void 0?void 0:_logs$chainId[filterKey];var result=state===null||state===void 0?void 0:state.results;if(!result){return{state:LogsState.LOADING,logs:undefined};}if(result.error){return{state:LogsState.ERROR,logs:undefined};}return{state:result.blockNumber>=blockNumber?LogsState.SYNCED:LogsState.SYNCING,logs:result.logs};},[blockNumber,chainId,filterKey,logs]);}","map":{"version":3,"sources":["/Users/safahi/Downloads/interface-4.30.1/src/state/logs/hooks.ts"],"names":["useEffect","useMemo","useActiveWeb3React","useBlockNumber","useAppDispatch","useAppSelector","addListener","removeListener","filterToKey","LogsState","useLogs","filter","chainId","blockNumber","logs","state","dispatch","filterKey","undefined","INVALID","result","results","LOADING","error","ERROR","SYNCED","SYNCING"],"mappings":"AAAA,OAASA,SAAT,CAAoBC,OAApB,KAAmC,OAAnC,CAEA,OAASC,kBAAT,KAAmC,kBAAnC,CACA,OAASC,cAAT,KAA+B,sBAA/B,CACA,OAASC,cAAT,CAAyBC,cAAzB,KAA+C,UAA/C,CACA,OAASC,WAAT,CAAsBC,cAAtB,KAA4C,SAA5C,CACA,OAAsBC,WAAtB,KAA8C,SAA9C,CAEA,UAAYC,CAAAA,SAAZ,C,UAAYA,S,EAAAA,S,CAAAA,S,yBAAAA,S,CAAAA,S,yBAAAA,S,CAAAA,S,yBAAAA,S,CAAAA,S,qBAAAA,S,CAAAA,S,0BAAAA,S,GAAAA,S,MAkBZ;AACA;AACA;AACA;AACA,GACA,MAAO,SAASC,CAAAA,OAAT,CAAiBC,MAAjB,CAAiE,CACtE,wBAAoBT,kBAAkB,EAAtC,CAAQU,OAAR,qBAAQA,OAAR,CACA,GAAMC,CAAAA,WAAW,CAAGV,cAAc,EAAlC,CAEA,GAAMW,CAAAA,IAAI,CAAGT,cAAc,CAAC,SAACU,KAAD,QAAWA,CAAAA,KAAK,CAACD,IAAjB,EAAD,CAA3B,CACA,GAAME,CAAAA,QAAQ,CAAGZ,cAAc,EAA/B,CAEAJ,SAAS,CAAC,UAAM,CACd,GAAI,CAACW,MAAD,EAAW,CAACC,OAAhB,CAAyB,OAEzBI,QAAQ,CAACV,WAAW,CAAC,CAAEM,OAAO,CAAPA,OAAF,CAAWD,MAAM,CAANA,MAAX,CAAD,CAAZ,CAAR,CACA,MAAO,WAAM,CACXK,QAAQ,CAACT,cAAc,CAAC,CAAEK,OAAO,CAAPA,OAAF,CAAWD,MAAM,CAANA,MAAX,CAAD,CAAf,CAAR,CACD,CAFD,CAGD,CAPQ,CAON,CAACC,OAAD,CAAUI,QAAV,CAAoBL,MAApB,CAPM,CAAT,CASA,GAAMM,CAAAA,SAAS,CAAGhB,OAAO,CAAC,iBAAOU,CAAAA,MAAM,CAAGH,WAAW,CAACG,MAAD,CAAd,CAAyBO,SAAtC,EAAD,CAAmD,CAACP,MAAD,CAAnD,CAAzB,CAEA,MAAOV,CAAAA,OAAO,CAAC,UAAM,mBACnB,GAAI,CAACW,OAAD,EAAY,CAACK,SAAb,EAA0B,CAACJ,WAA/B,CACE,MAAO,CACLC,IAAI,CAAEI,SADD,CAELH,KAAK,CAAEN,SAAS,CAACU,OAFZ,CAAP,CAKF,GAAMJ,CAAAA,KAAK,gBAAGD,IAAI,CAACF,OAAD,CAAP,wCAAG,cAAgBK,SAAhB,CAAd,CACA,GAAMG,CAAAA,MAAM,CAAGL,KAAH,SAAGA,KAAH,iBAAGA,KAAK,CAAEM,OAAtB,CACA,GAAI,CAACD,MAAL,CAAa,CACX,MAAO,CACLL,KAAK,CAAEN,SAAS,CAACa,OADZ,CAELR,IAAI,CAAEI,SAFD,CAAP,CAID,CAED,GAAIE,MAAM,CAACG,KAAX,CAAkB,CAChB,MAAO,CACLR,KAAK,CAAEN,SAAS,CAACe,KADZ,CAELV,IAAI,CAAEI,SAFD,CAAP,CAID,CAED,MAAO,CACLH,KAAK,CAAEK,MAAM,CAACP,WAAP,EAAsBA,WAAtB,CAAoCJ,SAAS,CAACgB,MAA9C,CAAuDhB,SAAS,CAACiB,OADnE,CAELZ,IAAI,CAAEM,MAAM,CAACN,IAFR,CAAP,CAID,CA3Ba,CA2BX,CAACD,WAAD,CAAcD,OAAd,CAAuBK,SAAvB,CAAkCH,IAAlC,CA3BW,CAAd,CA4BD","sourcesContent":["import { useEffect, useMemo } from 'react'\n\nimport { useActiveWeb3React } from '../../hooks/web3'\nimport { useBlockNumber } from '../application/hooks'\nimport { useAppDispatch, useAppSelector } from '../hooks'\nimport { addListener, removeListener } from './slice'\nimport { EventFilter, filterToKey, Log } from './utils'\n\nexport enum LogsState {\n  // The filter is invalid\n  INVALID,\n  // The logs are being loaded\n  LOADING,\n  // Logs are from a previous block number\n  SYNCING,\n  // Tried to fetch logs but received an error\n  ERROR,\n  // Logs have been fetched as of the latest block number\n  SYNCED,\n}\n\nexport interface UseLogsResult {\n  logs: Log[] | undefined\n  state: LogsState\n}\n\n/**\n * Returns the logs for the given filter as of the latest block, re-fetching from the library every block.\n * @param filter The logs filter, without `blockHash`, `fromBlock` or `toBlock` defined.\n * The filter parameter should _always_ be memoized, or else will trigger constant refetching\n */\nexport function useLogs(filter: EventFilter | undefined): UseLogsResult {\n  const { chainId } = useActiveWeb3React()\n  const blockNumber = useBlockNumber()\n\n  const logs = useAppSelector((state) => state.logs)\n  const dispatch = useAppDispatch()\n\n  useEffect(() => {\n    if (!filter || !chainId) return\n\n    dispatch(addListener({ chainId, filter }))\n    return () => {\n      dispatch(removeListener({ chainId, filter }))\n    }\n  }, [chainId, dispatch, filter])\n\n  const filterKey = useMemo(() => (filter ? filterToKey(filter) : undefined), [filter])\n\n  return useMemo(() => {\n    if (!chainId || !filterKey || !blockNumber)\n      return {\n        logs: undefined,\n        state: LogsState.INVALID,\n      }\n\n    const state = logs[chainId]?.[filterKey]\n    const result = state?.results\n    if (!result) {\n      return {\n        state: LogsState.LOADING,\n        logs: undefined,\n      }\n    }\n\n    if (result.error) {\n      return {\n        state: LogsState.ERROR,\n        logs: undefined,\n      }\n    }\n\n    return {\n      state: result.blockNumber >= blockNumber ? LogsState.SYNCED : LogsState.SYNCING,\n      logs: result.logs,\n    }\n  }, [blockNumber, chainId, filterKey, logs])\n}\n"]},"metadata":{},"sourceType":"module"}